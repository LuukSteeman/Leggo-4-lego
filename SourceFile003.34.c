#pragma config(Sensor, S1,     lightSensor,    sensorLightActive)
#pragma config(Sensor, S2,     sonar1,         sensorSONAR)
#pragma config(Sensor, S3,     colorSensor,    sensorColorNxtFULL)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(NXT)

long nLastXmitTimeStamp = nPgmTime;
long nDeltaTime         = 0;

const int kMaxSizeOfMessage = 30;
const int INBOX = 5;
			TFileIOResult nBTCmdRdErrorStatus;
  		int nSizeOfMessage;
  		ubyte nRcvBuffer[kMaxSizeOfMessage];

void app_move(string s, bool bocht){
		int tmp_right;
		int tmp_left;
		if (bocht == true) {
			tmp_right = -60;
			tmp_left = -90;
		}
		else {
			tmp_left = -45;
			tmp_right = -45;
		}

  	if (s == "UP"){
			nMotorEncoder[motorA] = 0;
			while (nMotorEncoder[motorA] > -45) {
				motor[motorA] = -30;
				motor[motorB] = -30;
			}
			motor[motorA] = 0;
			motor[motorB] = 0;
	}
	else if (s == "LEFT") {
			nMotorEncoder[motorA] = 0;
			while (nMotorEncoder[motorA] > tmp_left) {
				motor[motorA] = -20;
				motor[motorB] = 20;
			}
			motor[motorA] = 0;
			motor[motorB] = 0;
	}
	else if (s == "RIGHT") {
			nMotorEncoder[motorB] = 0;
			while (nMotorEncoder[motorB] > tmp_right) {
				motor[motorA] = 20;
				motor[motorB] = -20;
			}
			motor[motorA] = 0;
			motor[motorB] = 0;
	}
	else if (s == "DOWN") {
			nMotorEncoder[motorA] = 0;
			while (nMotorEncoder[motorA] < 45) {
				motor[motorA] = 30;
				motor[motorB] = 30;
			}
			motor[motorA] = 0;
			motor[motorB] = 0;
	}
	else if (s == "STOP") {
		motor[motorA] = 0;
		motor[motorB] = 0;
	}

}

/*
float power(float number,int n)
{
  float Z=number;
  for (int i=1;i<n;i++)
    Z*=number;
  return Z;
}
*/

task main()
{
	//motor[motorC] = -20;

	/** PDI Algorithm variables */
	int Kp = 200;
	int Ki = 6;
	int Kd = 2500 ;
	int offset = 55;
	int Tp = 25;
	int integral = 0;
	int lastError = 0;
	int derivative = 0;
	int LightValue = 0;
	int error = 0;
	int turn = 0;
	int powerA = 0;
	int powerB = 0;

	int app_timeout = 3000;
	bool stop_functie = true;					// if it's false the robot drives by itself and if it's true it drives by the app
	bool intersection = false;				// if true we are at intersection

	string app_message = "";					// the message from app
	wait1Msec(50);                        // The program waits 50 milliseconds to initialize the light sensor.
	while(true)                           // Infinite loop
	{
		/*** check if there is a message available from app ***/
    nSizeOfMessage = cCmdMessageGetSize(INBOX);

    if (nSizeOfMessage > kMaxSizeOfMessage){
      nSizeOfMessage = kMaxSizeOfMessage;
    }
  	/** store the message of the app into a variable*/
    if (nSizeOfMessage > 0) {
    	nBTCmdRdErrorStatus = cCmdMessageRead(nRcvBuffer, nSizeOfMessage, INBOX);
    	nRcvBuffer[nSizeOfMessage] = '\0';
    	stringFromChars(app_message, (char *) nRcvBuffer);
    	displayCenteredBigTextLine(4, app_message);
    	/* Stop or Start the robot by tapping on "Fire" */
    	if (app_message == "FIRE" && intersection == false) {
    		if (stop_functie == false) {
    			stop_functie = true;
    			app_message = "STOP";
    			app_move(app_message, false);
    			continue;
    		}
    		else if (stop_functie == true){
    			stop_functie = false;
    		}
    	}
	  }

		/*** if the robot drives by itself ***/
	  if (stop_functie == false) {

				/** check the sonar sensor and stop the robot if it see's sth **/
				if (intersection == false && SensorValue[sonar1] < 20) {
						int i = -15;
							while (i < 0) {
								motor[motorA] = i;
								motor[motorB] = i;
								i +=  4;
								wait1Msec(300);
						}
					motor[motorA] = 0;
					motor[motorB] = 0;
				}

				/** Detect intersections for the first time **/
				else if (SensorValue[colorSensor] ==  BLACKCOLOR && SensorValue[lightSensor] < 50) {
						playSound(soundException);
						int i = -15;
						while (i < 0) {
							motor[motorA] = i;
							motor[motorB] = i;
							i +=  4;
							wait1Msec(300);
					}
					motor[motorA] = 0;
					motor[motorB] = 0;
					intersection = true;
					/* Reset Timer1 value (only the first time the robot sees a intersection **/
					ClearTimer(T1);
				}

				/** if the robot is at intersection, wait for a message from app
						The time-out is max "app_timeout" **/
				else if (intersection == true) {

					if (time1[T1] < app_timeout) {
			    		if (nSizeOfMessage > 0){
			    			intersection = false;
			    			stop_functie = true;
			    			if (app_message == "FIRE") {
			    				stop_functie = false;
			    			}
			    			else if (app_message != "UP") {
			    				app_move(app_message, true);
			    			}
					    }
					}
					else if (time1[T1] > app_timeout){
						intersection = false;
					}
				}

				/** if there is no other condition: (NO intersection, No sonar) **/
				else if (intersection == false) {
					displayCenteredBigTextLine(4, "%d", SensorValue[lightSensor]);

					//motor[motorA] = -23 + power((float)(58 - SensorValue[lightSensor]) / 5.15, 3);
					//motor[motorB] = -23 - power((float)(58 - SensorValue[lightSensor]) / 5.15, 3);

					LightValue = SensorValue(lightSensor);
					error = LightValue - offset;
					integral = ((2/3)* integral) + error;
					derivative = error - lastError
					Turn = Kp*error + Ki*integral + Kd*derivative
					Turn = Turn/100;
					powerA = Tp + Turn;
					powerB = Tp - Turn;
					motor[motorA] = -1*powerA;
					motor[motorB] = -1*powerB;
					lastError = error;

				}
	}

	/*** if the robot drives by the app ***/
	else if (stop_functie == true) {
		app_move(app_message, false);
		app_message = "";
		}
}
}
